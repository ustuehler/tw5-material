title: mdc/v0.1.4-current
caption: >0.1.4
tags: $:/tags/ReleaseNotes
created: 20171119205328
modified: 20171119205328
released: 20171119205328

Changes between version 0.1.4 and HEAD:

```
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/FloatingActionButton.tid
@@ -0,0 +1,36 @@
+caption: Floating Action Button
+mdc-class: mdc-fab
+mdc-fab-icon: favorite
+title: $:/plugins/ustuehler/mdc/FloatingActionButton
+type: text/vnd.tiddlywiki
+
+\define this-transclusion()
+{$(currentTiddler)$|$(currentTiddler)$|||}
+\end
+\define this-tiddler()
+[<transclusion>prefix<this-transclusion>]]
+\end
+\define fab(position)
+<span class="mdc-fab material-icons tc-fab--$position$" aria-label="New">
+
+<$link to={{!!link-to}} class="mdc-fab__icon">
+
+<$transclude field="mdc-fab-icon" mode="inline">
+
+<$transclude tiddler="$:/plugins/ustuehler/mdc/FloatingActionButton" field="mdc-fab-icon" mode="inline"/>
+
+</$transclude>
+
+</$link>
+
+</span>
+\end
+
+<$list
+  variable=""
+  filter="[[$:/plugins/ustuehler/mdc/FloatingActionButton]is[current]]"
+  emptyMessage="""<<fab "absolute">>""">
+<<fab "relative">>
+</$list>
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/ListItem.tid
@@ -0,0 +1,25 @@
+caption: List Item
+link-to: 
+list-item-icon: list
+mdc-class: mdc-list-item
+tags: 
+title: $:/plugins/ustuehler/mdc/ListItem
+type: text/vnd.tiddlywiki
+
+<$set name="link-to" value={{!!link-to}} emptyValue=<<currentTiddler>>>
+
+<$link to=<<link-to>> class={{$:/plugins/ustuehler/mdc/ListItem!!mdc-class}}>
+
+{{||$:/plugins/ustuehler/mdc/ListItem/StartDetail}}
+
+<$transclude field="caption" mode="inline">
+
+<$view field="title"/>
+
+</$transclude>
+
+</$link>
+
+</$set>
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/ListItem/Divider.tid
@@ -0,0 +1,6 @@
+title: $:/plugins/ustuehler/mdc/ListItem/Divider
+type: text/vnd.tiddlywiki
+
+<hr class="mdc-list-divider">
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/ListItem/StartDetail.tid
@@ -0,0 +1,9 @@
+tags: 
+title: $:/plugins/ustuehler/mdc/ListItem/StartDetail
+type: text/vnd.tiddlywiki
+
+<$transclude field="list-item-start-detail">
+<$transclude tiddler="$:/plugins/ustuehler/mdc/ListItem/StartDetail/Icon"/>
+</$transclude>
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/ListItem/StartDetail/icon.tid
@@ -0,0 +1,12 @@
+list-item-icon: favorite
+tags: 
+title: $:/plugins/ustuehler/mdc/ListItem/StartDetail/Icon
+type: text/vnd.tiddlywiki
+
+<i class="material-icons mdc-list-item__start-detail" aria-hidden="true">
+
+<$transclude field="list-item-icon" mode="inline"/>
+
+</i>
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/changelog.tid
@@ -0,0 +1,9 @@
+caption: MDC Plugin
+title: $:/plugins/ustuehler/mdc/changelog
+type: text/vnd.tiddlywiki
+
+<$list filter="[prefix[mdc/v]!sort[released]limit[1]]">
+  <$macrocall $name="tabs" tabsList="[prefix[mdc/v]!sort[released]]" default={{!!title}} class="tc-vertical" template="ReleaseTemplate" />
+</$list>
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/images/storyview-replace.tid
@@ -0,0 +1,8 @@
+title: $:/core/images/storyview-replace
+tags: $:/tags/Image
+
+<svg class="tc-image-storyview-replace tc-image-button" width="22pt" height="22pt" viewBox="0 0 128 128">
+    <g fill-rule="evenodd">
+        <path d="M8.00697327,0 C3.58484404,0 0,3.59075293 0,8.00697327 L0,119.993027 C0,124.415156 3.59075293,128 8.00697327,128 L119.993027,128 C124.415156,128 128,124.409247 128,119.993027 L128,8.00697327 C128,3.58484404 124.409247,0 119.993027,0 L8.00697327,0 L8.00697327,0 Z M23.9992458,16 C19.5813843,16 16,19.578055 16,24.0085154 L16,71.9914846 C16,76.4144655 19.5881049,80 23.9992458,80 L104.000754,80 C108.418616,80 112,76.421945 112,71.9914846 L112,24.0085154 C112,19.5855345 108.411895,16 104.000754,16 L23.9992458,16 L23.9992458,16 Z"></path>
+    </g>
+</svg>
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/macros/drawer.tid
@@ -0,0 +1,26 @@
+caption: drawer
+tags: $:/tags/Macro
+title: $:/plugins/ustuehler/mdc/macros/drawer
+type: text/vnd.tiddlywiki
+
+\define drawer(filter:"[all[shadows+tiddlers]tag[$:/tags/DrawerTemplate]]" class:"mdc-temporary-drawer" headerText:"")
+<aside class="$class$">
+  <nav class='$class$__drawer'>
+    <header class="$class$__header">
+      <div class="$class$__header-content mdc-theme--primary-bg mdc-theme--text-primary-on-primary">
+        {{$:/GitHubForkRibbon}}
+        [img width="100%" height="100%"
+ [https://material.io/components/images/welcome/root.svg]]
+        $headerText$
+      </div>
+    </header>
+    <nav class="$class$__content mdc-list-group">
+      <$list filter="$filter$">
+        <$transclude/>
+      </$list>
+    </nav>
+  </nav>
+</aside>
+\end
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/plugin.info
@@ -0,0 +1,8 @@
+{
+	"title": "$:/plugins/ustuehler/mdc",
+	"version": "0.1.4",
+	"core-version": ">=5.1.14",
+	"author": "Uwe Stuehler",
+	"description": "Material Design components (needs MDC-Web assets)",
+	"list": "readme usage changelog license"
+}
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/readme.tid
@@ -0,0 +1,8 @@
+title: $:/plugins/ustuehler/mdc/readme
+type: text/vnd.tiddlywiki
+
+This plugin provides macros and widgets to make the [[Material Components Catalog|http://material-components-web.appspot.com/]] accessible in WikiText.
+
+It relies on assets provided by either of the plugins [[mdc-web|$:/plugins/ustuehler/mdc-web]] or [[mdc-web-cdn|$:/plugins/ustuehler/mdc-web-cdn]].
\ No newline at end of file
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/storyviews/replace.js
@@ -0,0 +1,211 @@
+/*\
+title: $:/plugins/ustuehler/mdc/storyviews/replace.js
+type: application/javascript
+module-type: storyview
+
+Single-tiddler story view without transition (modified from zoomin.js as a quick hack, because zoomin had some CSS issues)
+
+\*/
+(function(){
+
+/*jslint node: true, browser: true */
+/*global $tw: false */
+"use strict";
+
+var easing = "cubic-bezier(0.645, 0.045, 0.355, 1)"; // From http://easings.net/#easeInOutCubic
+
+var ReplaceListView = function(listWidget) {
+	var self = this;
+	this.listWidget = listWidget;
+	// Get the index of the tiddler that is at the top of the history
+	var history = this.listWidget.wiki.getTiddlerDataCached(this.listWidget.historyTitle,[]),
+		targetTiddler;
+	if(history.length > 0) {
+		targetTiddler = history[history.length-1].title;
+	}
+	// Make all the tiddlers position absolute, and hide all but the top (or first) one
+	$tw.utils.each(this.listWidget.children,function(itemWidget,index) {
+		var domNode = itemWidget.findFirstDomNode();
+		// Abandon if the list entry isn't a DOM element (it might be a text node)
+		if(!(domNode instanceof Element)) {
+			return;
+		}
+		if((targetTiddler && targetTiddler !== itemWidget.parseTreeNode.itemTitle) || (!targetTiddler && index)) {
+			domNode.style.display = "none";
+		} else {
+			self.currentTiddlerDomNode = domNode;
+		}
+		$tw.utils.addClass(domNode,"tc-storyview-replace-tiddler");
+	});
+};
+
+ReplaceListView.prototype.navigateTo = function(historyInfo) {
+	var duration = $tw.utils.getAnimationDuration(),
+		listElementIndex = this.listWidget.findListItem(0,historyInfo.title);
+	if(listElementIndex === undefined) {
+		return;
+	}
+	var listItemWidget = this.listWidget.children[listElementIndex],
+		targetElement = listItemWidget.findFirstDomNode();
+	// Abandon if the list entry isn't a DOM element (it might be a text node)
+	if(!(targetElement instanceof Element)) {
+		return;
+	}
+	// Make the new tiddler be position absolute and visible so that we can measure it
+	$tw.utils.addClass(targetElement,"tc-storyview-replace-tiddler");
+	$tw.utils.setStyle(targetElement,[
+		{display: "block"},
+		{transformOrigin: "0 0"},
+		{transform: "translateX(0px) translateY(0px) scale(1)"},
+		{transition: "none"},
+		{opacity: "0.0"}
+	]);
+	// Get the position of the source node, or use the centre of the window as the source position
+	var sourceBounds = historyInfo.fromPageRect || {
+			left: window.innerWidth/2 - 2,
+			top: window.innerHeight/2 - 2,
+			width: window.innerWidth/8,
+			height: window.innerHeight/8
+		};
+	// Try to find the title node in the target tiddler
+	var titleDomNode = findTitleDomNode(listItemWidget) || listItemWidget.findFirstDomNode(),
+		zoomBounds = titleDomNode.getBoundingClientRect();
+	// Compute the transform for the target tiddler to make the title lie over the source rectange
+	var targetBounds = targetElement.getBoundingClientRect(),
+		scale = sourceBounds.width / zoomBounds.width,
+		x = sourceBounds.left - targetBounds.left - (zoomBounds.left - targetBounds.left) * scale,
+		y = sourceBounds.top - targetBounds.top - (zoomBounds.top - targetBounds.top) * scale;
+	// Transform the target tiddler to its starting position
+	$tw.utils.setStyle(targetElement,[
+		{transform: "translateX(" + x + "px) translateY(" + y + "px) scale(" + scale + ")"}
+	]);
+	// Force layout
+	$tw.utils.forceLayout(targetElement);
+	// Apply the ending transitions with a timeout to ensure that the previously applied transformations are applied first
+	var self = this,
+		prevCurrentTiddler = this.currentTiddlerDomNode;
+	this.currentTiddlerDomNode = targetElement;
+	// Transform the target tiddler to its natural size
+	$tw.utils.setStyle(targetElement,[
+		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
+		{opacity: "1.0"},
+		{transform: "translateX(0px) translateY(0px) scale(1)"},
+		{zIndex: "0"},
+	]);
+	// Transform the previous tiddler out of the way and then hide it
+	if(prevCurrentTiddler && prevCurrentTiddler !== targetElement) {
+		scale = zoomBounds.width / sourceBounds.width;
+		x =  zoomBounds.left - targetBounds.left - (sourceBounds.left - targetBounds.left) * scale;
+		y =  zoomBounds.top - targetBounds.top - (sourceBounds.top - targetBounds.top) * scale;
+		$tw.utils.setStyle(prevCurrentTiddler,[
+			{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
+			{opacity: "0.0"},
+			{transformOrigin: "0 0"},
+			{transform: "translateX(" + x + "px) translateY(" + y + "px) scale(" + scale + ")"},
+			{zIndex: "0"}
+		]);
+		// Hide the tiddler when the transition has finished
+		setTimeout(function() {
+			if(self.currentTiddlerDomNode !== prevCurrentTiddler) {
+				prevCurrentTiddler.style.display = "none";
+			}
+		},duration);
+	}
+	// Scroll the target into view
+//	$tw.pageScroller.scrollIntoView(targetElement);
+};
+
+/*
+Find the first child DOM node of a widget that has the class "tc-title"
+*/
+function findTitleDomNode(widget,targetClass) {
+	targetClass = targetClass || "tc-title";
+	var domNode = widget.findFirstDomNode();
+	if(domNode && domNode.querySelector) {
+		return domNode.querySelector("." + targetClass);
+	}
+	return null;
+}
+
+ReplaceListView.prototype.insert = function(widget) {
+	var targetElement = widget.findFirstDomNode();
+	// Abandon if the list entry isn't a DOM element (it might be a text node)
+	if(!(targetElement instanceof Element)) {
+		return;
+	}
+	// Make the newly inserted node position absolute and hidden
+	$tw.utils.addClass(targetElement,"tc-storyview-replace-tiddler");
+	$tw.utils.setStyle(targetElement,[
+		{display: "none"}
+	]);
+};
+
+ReplaceListView.prototype.remove = function(widget) {
+	var targetElement = widget.findFirstDomNode(),
+		duration = $tw.utils.getAnimationDuration(),
+		removeElement = function() {
+			widget.removeChildDomNodes();
+		};
+	// Abandon if the list entry isn't a DOM element (it might be a text node)
+	if(!(targetElement instanceof Element)) {
+		removeElement();
+		return;
+	}
+	// Abandon if hidden
+	if(targetElement.style.display != "block" ) {
+		removeElement();
+		return;
+	}
+	// Set up the tiddler that is being closed
+	$tw.utils.addClass(targetElement,"tc-storyview-replace-tiddler");
+	$tw.utils.setStyle(targetElement,[
+		{display: "block"},
+		{transformOrigin: "50% 50%"},
+		{transform: "translateX(0px) translateY(0px) scale(1)"},
+		{transition: "none"},
+		{zIndex: "0"}
+	]);
+	// We'll move back to the previous or next element in the story
+	var toWidget = widget.previousSibling();
+	if(!toWidget) {
+		toWidget = widget.nextSibling();
+	}
+	var toWidgetDomNode = toWidget && toWidget.findFirstDomNode();
+	// Set up the tiddler we're moving back in
+	if(toWidgetDomNode) {
+		$tw.utils.addClass(toWidgetDomNode,"tc-storyview-replace-tiddler");
+		$tw.utils.setStyle(toWidgetDomNode,[
+			{display: "block"},
+			{transformOrigin: "50% 50%"},
+			{transform: "translateX(0px) translateY(0px) scale(10)"},
+			{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
+			{opacity: "0"},
+			{zIndex: "0"}
+		]);
+		this.currentTiddlerDomNode = toWidgetDomNode;
+	}
+	// Animate them both
+	// Force layout
+	$tw.utils.forceLayout(this.listWidget.parentDomNode);
+	// First, the tiddler we're closing
+	$tw.utils.setStyle(targetElement,[
+		{transformOrigin: "50% 50%"},
+		{transform: "translateX(0px) translateY(0px) scale(0.1)"},
+		{transition: $tw.utils.roundTripPropertyName("transform") + " " + duration + "ms " + easing + ", opacity " + duration + "ms " + easing},
+		{opacity: "0"},
+		{zIndex: "0"}
+	]);
+	setTimeout(removeElement,duration);
+	// Now the tiddler we're going back to
+	if(toWidgetDomNode) {
+		$tw.utils.setStyle(toWidgetDomNode,[
+			{transform: "translateX(0px) translateY(0px) scale(1)"},
+			{opacity: "1"}
+		]);
+	}
+	return true; // Indicate that we'll delete the DOM node
+};
+
+exports.replace = ReplaceListView;
+
+})();
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/utils.js
@@ -0,0 +1,19 @@
+/*\
+title: $:/plugins/ustuehler/mdc/utils.js
+type: application/javascript
+module-type: utils
+
+Utility methods like showSnackbar()
+
+\*/
+(function() {
+'use strict';
+
+exports.showSnackbar = function(message, timeout) {
+  $tw.rootWidget.findFirstDomNode().querySelector('.mdc-snackbar').widget.show({
+    message: message,
+    timeout: timeout || 2750
+  });
+};
+
+}());
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/widgets/action-showsnackbar.js
@@ -0,0 +1,94 @@
+/*\
+title: $:/plugins/ustuehler/mdc/widgets/action-showsnackbar.js
+type: application/javascript
+module-type: widget
+caption: action-showsnackbar
+
+Action widget that shows the first snackbar found in the document with a message and optional action button
+
+\*/
+(function () {
+
+"use strict";
+/*jslint node: true, browser: true */
+/*global $tw: false */
+
+var Widget = require("$:/core/modules/widgets/widget.js").widget;
+
+var ActionShowSnackbarWidget = function(parseTreeNode,options) {
+	this.initialise(parseTreeNode,options);
+};
+
+/*
+Inherit from the base widget class
+*/
+ActionShowSnackbarWidget.prototype = new Widget();
+
+/*
+Render this widget into the DOM
+*/
+ActionShowSnackbarWidget.prototype.render = function(parent,nextSibling) {
+	this.computeAttributes();
+	this.execute();
+};
+
+/*
+Compute the internal state of the widget
+*/
+ActionShowSnackbarWidget.prototype.execute = function() {
+	this.message = this.getAttribute("message", "");
+	this.actionText = this.getAttribute("actionText", "");
+	this.timeout = parseInt(this.getAttribute("timeout", "2750"));
+
+  // Compute the internal state of child widgets.
+  this.makeChildWidgets();
+};
+
+/*
+Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
+*/
+ActionShowSnackbarWidget.prototype.refresh = function(changedTiddlers) {
+  var changedAttributes = this.computeAttributes();
+
+  if (changedAttributes.message || changedAttributes.actionText || changedAttributes.timeout) {
+    this.refreshSelf();
+    return true;
+  }
+
+  return this.refreshChildren(changedTiddlers);
+};
+
+/*
+ * Invoke the action associated with this widget
+ */
+ActionShowSnackbarWidget.prototype.invokeAction = function(triggeringWidget,event) {
+  var self = this;
+  var snackbar = this.document.getElementsByClassName("mdc-snackbar")[0];
+
+  if (snackbar !== undefined) {
+    var data = {
+      message: this.message,
+      actionText: this.actionText,
+      actionHandler: function() {
+        console.log("Invoking child action widgets");
+        self.invokeActions(triggeringWidget,event);
+      },
+      timeout: this.timeout
+    };
+
+    snackbar.widget.show(data);
+  }
+
+  return true; // Action was invoked
+}
+
+/*
+ * Don't allow actions to propagate, because we invoke actions ourself
+ */
+ActionShowSnackbarWidget.prototype.allowActionPropagation = function() {
+  return false;
+};
+
+exports["action-showsnackbar"] = ActionShowSnackbarWidget;
+
+})();
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/widgets/action-toggledrawer.js
@@ -0,0 +1,104 @@
+/*\
+title: $:/plugins/ustuehler/mdc/widgets/action-toggledrawer.js
+type: application/javascript
+module-type: widget
+caption: action-toggledrawer
+
+Action widget that toggles the visibility of the first drawer found in the document
+
+\*/
+(function (global) {
+
+"use strict";
+/*jslint node: true, browser: true */
+/*global $tw: false */
+
+var drawerTypes = {
+  permanent: {
+    class: "MDCPermanentDrawer",
+    selector: ".mdc-permanent-drawer"
+  },
+  persistent: {
+    class: "MDCPersistentDrawer",
+    selector: ".mdc-persistent-drawer"
+  },
+  temporary: {
+    class: "MDCTemporaryDrawer",
+    selector: ".mdc-temporary-drawer"
+  }
+};
+
+var Widget = require("$:/core/modules/widgets/widget.js").widget;
+
+var ActionToggleDrawerWidget = function(parseTreeNode,options) {
+	this.initialise(parseTreeNode,options);
+};
+
+/*
+Inherit from the base widget class
+*/
+ActionToggleDrawerWidget.prototype = new Widget();
+
+/*
+Render this widget into the DOM
+*/
+ActionToggleDrawerWidget.prototype.render = function(parent,nextSibling) {
+	this.computeAttributes();
+	this.execute();
+};
+
+/*
+Compute the internal state of the widget
+*/
+ActionToggleDrawerWidget.prototype.execute = function() {
+  this.type = this.getAttribute("type", "temporary")
+  if (!drawerTypes[this.type]) {
+    throw Error("invalid drawer type: " + this.type);
+  }
+  this["class"] = drawerTypes[this.type]["class"];
+  this.selector = drawerTypes[this.type].selector;
+  // Compute the internal state of child widgets.
+  this.makeChildWidgets();
+};
+
+/*
+Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
+*/
+ActionToggleDrawerWidget.prototype.refresh = function(changedTiddlers) {
+  var changedAttributes = this.computeAttributes();
+
+  if (changedAttributes["class"] || changedAttributes.selector) {
+    this.refreshSelf();
+    return true;
+  }
+
+  return this.refreshChildren(changedTiddlers);
+};
+
+/*
+ * Invoke the action associated with this widget
+ */
+ActionToggleDrawerWidget.prototype.invokeAction = function(triggeringWidget,event) {
+  var self = this;
+  var el = this.document.querySelector(this.selector);
+
+  if (el) {
+    var constructor = global.mdc.drawer[this["class"]];
+    var drawer = new constructor(el);
+
+    drawer.open = !drawer.open;
+  }
+
+  return true; // Action was invoked
+}
+
+/*
+ * Don't allow actions to propagate, because we invoke actions ourself
+ */
+ActionToggleDrawerWidget.prototype.allowActionPropagation = function() {
+  return false;
+};
+
+exports["action-toggledrawer"] = ActionToggleDrawerWidget;
+
+})(this);
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/widgets/mdc-auto-init.js
@@ -0,0 +1,73 @@
+/*\
+title: $:/plugins/ustuehler/mdc/widgets/mdc-auto-init.js
+type: application/javascript
+module-type: widget
+caption: mdc-auto-init
+
+mdc-auto-init widget to initialize MDC-Web components from HTML elements
+
+\*/
+(function (global) {
+
+"use strict";
+/*jslint node: true, browser: true */
+/*global $tw: false */
+
+var Widget = require("$:/core/modules/widgets/widget.js").widget;
+
+var MDCAutoInitWidget = function(parseTreeNode,options) {
+	this.initialise(parseTreeNode,options);
+};
+
+/*
+Inherit from the base widget class
+*/
+MDCAutoInitWidget.prototype = new Widget();
+
+/*
+Render this widget into the DOM
+*/
+MDCAutoInitWidget.prototype.render = function(parent,nextSibling) {
+	//var self = this;
+
+	// Compute attributes and execute state
+	this.computeAttributes();
+	this.execute();
+
+  // Insert DOM node
+  var domNode = this.document.createElement("div");
+  domNode.setAttribute("class","mdc-auto-init");
+	parent.insertBefore(domNode,nextSibling);
+	this.renderChildren(domNode,null);
+  this.domNodes.push(domNode);
+
+  // For each child widget run mdc.autoInit()
+  if (this.window) {
+    this.window.mdc.autoInit(domNode);
+  } else {
+    console.log("warning: this.window should be set in MDCAutoInitWidget.render()?");
+  }
+};
+
+/*
+Compute the internal state of the widget
+*/
+MDCAutoInitWidget.prototype.execute = function() {
+  this.makeChildWidgets();
+};
+
+/*
+Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
+*/
+MDCAutoInitWidget.prototype.refresh = function(changedTiddlers) {
+  if (this.refreshChildren(changedTiddlers)) {
+    this.refreshSelf();
+    return true;
+  }
+
+  return false;
+};
+
+exports["mdc-auto-init"] = MDCAutoInitWidget;
+
+})(this);
new file mode 100644
--- /dev/null
+++ b/plugins/ustuehler/mdc/widgets/snackbar.js
@@ -0,0 +1,119 @@
+/*\
+title: $:/plugins/ustuehler/mdc/widgets/snackbar.js
+type: application/javascript
+module-type: widget
+caption: snackbar
+
+Snackbar widget using MDC-Web components
+
+\*/
+(function (global) {
+
+"use strict";
+/*jslint node: true, browser: true */
+/*global $tw: false */
+
+var Widget = require("$:/core/modules/widgets/widget.js").widget;
+
+var SnackbarWidget = function(parseTreeNode,options) {
+	this.initialise(parseTreeNode,options);
+};
+
+/*
+Inherit from the base widget class
+*/
+SnackbarWidget.prototype = new Widget();
+
+/*
+Render this widget into the DOM
+*/
+SnackbarWidget.prototype.render = function(parent,nextSibling) {
+	//var self = this;
+
+	// Compute attributes and execute state
+	this.computeAttributes();
+	this.execute();
+
+  // Create text element
+	var textNode = this.document.createElement("div");
+	textNode.setAttribute("class","mdc-snackbar__text");
+	textNode.textContent = this.message;
+
+  // Create action button element
+	var actionButtonNode = this.document.createElement("button");
+	actionButtonNode.setAttribute("class","mdc-snackbar__action-button");
+	actionButtonNode.textContent = this.actionButtonLabel;
+
+  // Create action wrapper element
+	var actionWrapperNode = this.document.createElement("div");
+	actionWrapperNode.setAttribute("class","mdc-snackbar__action-wrapper");
+  actionWrapperNode.appendChild(actionButtonNode);
+
+	// Create snackbar element
+	var domNode = this.document.createElement("div");
+	domNode.setAttribute("class","mdc-snackbar");
+	domNode.setAttribute("aria-live","assertive");
+	domNode.setAttribute("aria-atomic","true");
+	domNode.setAttribute("aria-hidden","true");
+	domNode.appendChild(textNode);
+	domNode.appendChild(actionWrapperNode);
+
+  // Create the snackbar behaviour
+  var MDCSnackbar = global.mdc.snackbar.MDCSnackbar;
+  var snackbar = new MDCSnackbar(domNode);
+  snackbar.dismissesOnAction = true;
+  this.snackbar = snackbar;
+
+	// Insert element
+	parent.insertBefore(domNode,nextSibling);
+	this.renderChildren(domNode,null);
+	this.domNodes.push(domNode);
+
+  // Allow access to this widget via the DOM node (for $action-showsnackbar)
+  domNode.widget = this;
+};
+
+/*
+Compute the internal state of the widget
+*/
+SnackbarWidget.prototype.execute = function() {
+};
+
+/*
+Show the snackbar
+*/
+SnackbarWidget.prototype.show = function(data) {
+  if (this.snackbar) {
+    var data2 = {
+      message: data.message || "",
+      timeout: data.timeout || 2750
+    };
+
+    if (data.actionText) {
+      data2.actionText = data.actionText;
+      data2.actionHandler = data.actionHandler || function() {
+        console.log(data2.actionText);
+      }
+    }
+
+    this.snackbar.show(data2);
+  }
+};
+
+/*
+Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering
+*/
+SnackbarWidget.prototype.refresh = function(changedTiddlers) {
+  var changedAttributes = this.computeAttributes();
+
+  if (changedAttributes.message || changedAttributes.actionButtonLabel) {
+    this.refreshSelf();
+    return true;
+  }
+
+  return this.refreshChildren(changedTiddlers);
+};
+
+exports["snackbar"] = SnackbarWidget;
+
+})(this);
```